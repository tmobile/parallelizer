// Copyright (c) 2020 T-Mobile
//
// Licensed under the Apache License, Version 2.0 (the "License"); you
// may not use this file except in compliance with the License.  You
// may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied.  See the License for the specific language governing
// permissions and limitations under the License.

package parallelizer

import "github.com/stretchr/testify/mock"

// MockRunner is a mock for the Runner interface.  It is provided to
// facilitate internal testing of the Runner implementations, but may
// be used by external users to test other code that utilizes a
// Runner.
type MockRunner struct {
	mock.Mock
}

// Run is the method that will be called to actually process the data.
// It will be passed the data that was passed to Worker.Call, and may
// return data that will be subsequently passed to the Integrate
// method.  The Run method may be called from any number of goroutines
// (workers), so any resources it interacts with, including those
// embedded in the object, must be accessed in a thread-safe fashion.
//
// It is not safe for Run to make any calls to Worker.Call; this may
// potentially lead to a deadlock scenario.  Instead, return those
// items and handle the calls to Worker.Call from the Integrate
// method.
func (m *MockRunner) Run(data interface{}) interface{} {
	args := m.MethodCalled("Run", data)

	return args.Get(0)
}

// Integrate is used to combine all the data returned by Run method
// invocations.  It is passed a Worker object, which it may use to
// make additional calls to Worker.Call, even if Worker.Wait has been
// called.  All instances of Integrate operate synchronously in a
// single goroutine, and must not block; a side-effect is that the
// elements they interact with may be safely accessed without concern
// for parallel calls to Integrate.  The idea of Integrate is to allow
// the results from the various Run method calls to be combined
// together into a single result, which may then be obtained through a
// call to Result.  Note that if Run panics, the data will be passed
// to Integrate as the "panicData" parameter, and the "result"
// parameter will be nil.
//
// Note that Integrate is not running in the same goroutine as that
// which is making Worker.Call calls; in fact, those calls may be from
// multiple goroutines.
func (m *MockRunner) Integrate(worker Worker, result *Result) {
	m.MethodCalled("Integrate", worker, result)
}

// Result is called by the Worker.Wait method a single time, once all
// the worker goroutines have been terminated.  It is intended to work
// in conjunction with Integrate to enable the final result of the
// work to be reported to the caller of Worker.Wait.  It runs in the
// same goroutine as Worker.Wait, and need not worry about any other
// goroutine calling any other method from the Runner.
func (m *MockRunner) Result() interface{} {
	args := m.MethodCalled("Result")

	return args.Get(0)
}

// MockWorker is a mock for the Worker interface.  It is provided to
// facilitate testing code that utilizes Worker implementations.
type MockWorker struct {
	mock.Mock
}

// Call is the method used to submit data to be worked in a call to
// the Runner.Run method.  It may return an error if the worker has
// been shut down through a call to Wait.
func (m *MockWorker) Call(data interface{}) error {
	args := m.MethodCalled("Call", data)

	return args.Error(0)
}

// Wait is called to shut down the worker and return the final result;
// it will block the caller until all data has been processed and all
// worker goroutines have stopped.  Note that the final result,
// generated by Runner.Result, is saved by Worker to satisfy later
// calls to Wait.  If Wait is called before any calls to Call, the
// worker will go straight to a stopped state, and no further Call
// calls may be made; no error will be returned in that case.
func (m *MockWorker) Wait() (interface{}, error) {
	args := m.MethodCalled("Wait")

	return args.Get(0), args.Error(1)
}

// MockDoer is a mock for the Doer interface.  It is provided to
// facilitate testing code that utilizes the serializer.
type MockDoer struct {
	mock.Mock
}

// Do does some operation.  It receives some data and returns some
// result.  A serializer wraps a Doer to ensure the operation is done
// in a single goroutine, synchronously.
func (m *MockDoer) Do(data interface{}) interface{} {
	args := m.MethodCalled("Do", data)

	return args.Get(0)
}

// Finish is called when the manager goroutine of a Serializer
// implementation has been signaled to exit.  It may return a value,
// which becomes the return value from Serializer.Wait.
func (m *MockDoer) Finish() interface{} {
	args := m.MethodCalled("Finish")

	return args.Get(0)
}

// MockCallResult is a mock for the CallResult interface.  It is
// provided to facilitate testing code that utilizes the serializer.
type MockCallResult struct {
	mock.Mock
}

// Wait is used to retrieve the result of the call.  The result is not
// cached in the CallResult object, so subsequent calls to Wait will
// return nil.
func (m *MockCallResult) Wait() *Result {
	args := m.MethodCalled("Wait")

	if result := args.Get(0); result != nil {
		return result.(*Result)
	}

	return nil
}

// TryWait is a non-blocking variant of Wait.  It attempts to retrieve
// the result, and returns the value and a boolean value that
// indicates whether the result has already been retrieved.
func (m *MockCallResult) TryWait() (*Result, bool) {
	args := m.MethodCalled("TryWait")

	if result := args.Get(0); result != nil {
		return result.(*Result), args.Bool(1)
	}

	return nil, args.Bool(1)
}

// Channel returns the channel that the CallResult object uses to
// receive the results.  This allows the caller to directly select on
// the channel.  Note that if the result has already been received,
// the channel returned by this method will be nil.  Using this method
// effectively closes the CallResult; subsequent calls to Wait and
// TryWait will return nil results.
func (m *MockCallResult) Channel() <-chan *Result {
	args := m.MethodCalled("Channel")

	if resultChan := args.Get(0); resultChan != nil {
		return resultChan.(<-chan *Result)
	}

	return nil
}

// MockSerializer is a mock for the Serializer interface.  It is
// provided to facilitate testing code that utilizes Serializer
// implementations.
type MockSerializer struct {
	mock.Mock
}

// Call is used to invoke the Doer.Do method of the wrapped Doer.  It
// may return an error if the Serializer is closed.  Call is
// synchronous, and will not return until the Doer.Do method has
// completed.
func (m *MockSerializer) Call(data interface{}) (*Result, error) {
	args := m.MethodCalled("Call", data)

	if result := args.Get(0); result != nil {
		return result.(*Result), args.Error(1)
	}

	return nil, args.Error(1)
}

// CallAsync is used to invoke the Doer.Do method, like Call, but it
// does not block; instead, it returns a CallResult object, which may
// be queried later for the result of the call.
func (m *MockSerializer) CallAsync(data interface{}) (CallResult, error) {
	args := m.MethodCalled("CallAsync", data)

	if result := args.Get(0); result != nil {
		return result.(CallResult), args.Error(1)
	}

	return nil, args.Error(1)
}

// CallOnly is used to invoke the Doer.Do method, but it does not
// block; instead, the result of the call is discarded.
func (m *MockSerializer) CallOnly(data interface{}) error {
	args := m.MethodCalled("CallOnly", data)

	return args.Error(0)
}

// Wait signals the manager goroutine to exit, then waits for it to do
// so.  The manager will call the Doer.Finish method and return its
// result to Wait, which will in turn return it to the caller.  The
// result will be cached to satisfy future calls to Wait.
func (m *MockSerializer) Wait() interface{} {
	args := m.MethodCalled("Wait")

	return args.Get(0)
}
