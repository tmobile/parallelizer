// Copyright (c) 2020 Kevin L. Mitchell
//
// Licensed under the Apache License, Version 2.0 (the "License"); you
// may not use this file except in compliance with the License.  You
// may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied.  See the License for the specific language governing
// permissions and limitations under the License.

package parallelizer

import "container/list"

// synchronousWorker is an implementation of the Worker interface that
// operates in a synchronous fashion; that is, there are no goroutines
// involved.  It might be used when adapting an existing synchronous
// algorithm to a parallel algorithm, or it might be used when the
// parallelization is intended to be optional, such as when ordering
// may be important.
type synchronousWorker struct {
	runner     Runner      // The runner to be invoked by the workers
	queue      *list.List  // A queue of submitted work items
	closed     bool        // A flag indicating that the worker is closed
	running    bool        // A flag indicating that Call is running
	haveResult bool        // A flag indicating that we have a result
	result     interface{} // The result that came from calling Runner.Result
}

// A synchronous worker has some subtle logic going on.  First, Call
// and Wait may be called by the Integrate method of the Runner; so,
// we have to protect Call to allow additional items to be added to
// the queue--so we don't end up with a deep stack.  Second, Wait
// cannot return until all items added to the queue have been
// processed; so it has to also be able to process calls (thus the run
// method below).  Fortunately, the specification allows Wait to
// inhibit further calls to Call; that's done with the "closed" flag,
// and the "running" flag allows Call to just enqueue items when
// called from Integrate.  However, we could end up with a scenario
// where Call has called Integrate, which has called Wait, which has
// to run some items, where another Integrate call also calls Wait; to
// avoid calling Result multiple times in this scenario, we protect
// the "result" field by a "haveResult" boolean.

// NewSynchronousWorker constructs a synchronous worker.  Synchronous
// workers do not utilize parallelism at all; they are provided to
// allow for transition from a single-threaded algorithm to a
// multithreaded one, or to enable optional parallelization in cases
// where ordering may be important for certain invocations.
func NewSynchronousWorker(runner Runner) Worker {
	return &synchronousWorker{
		runner: runner,
		queue:  &list.List{},
	}
}

// run is a helper that runs the items on the queue.
func (w *synchronousWorker) run() {
	for w.queue.Len() > 0 {
		// Get an element off the queue
		elem := w.queue.Front()
		w.queue.Remove(elem)

		// Run the runner with that data
		result := w.runner.Run(elem.Value)

		// Integrate the results
		w.runner.Integrate(w, result)
	}
}

// Call is the method used to submit data to be worked in a call to
// the Runner.Run method.  It may return an error if the parallelizer
// has been shut down through a call to Wait.
func (w *synchronousWorker) Call(data interface{}) error {
	// First, check if the worker is closed
	if w.closed {
		return ErrWorkerClosed
	}

	// Enqueue the data
	w.queue.PushBack(data)

	// If we're running, avoid recursion and allow the outside
	// Call to do it all
	if w.running {
		return nil
	}
	w.running = true

	// Run the queue
	w.run()

	// Done running
	w.running = false

	return nil
}

// Wait is called to shut down the parallelizer and return the final
// result; it will block the worker until all data has been processed
// and all worker goroutines have stopped.  Note that the final
// result, generated by Runner.Result, is saved by Worker to satisfy
// later calls to Wait.  If Wait is called before any calls to Call,
// the parallelizer will go straight to a stopped state, and no
// further Call calls may be made; the return value will be nil in
// that case.
func (w *synchronousWorker) Wait() interface{} {
	// If we have the result, return it
	if w.haveResult {
		return w.result
	}

	// Close the worker so no new items get added
	w.closed = true

	// If there's more in the queue, we need to finish executing
	// it
	if w.queue.Len() > 0 {
		w.run()
	}

	// Check if another Wait set the result before we overwrite it
	if !w.haveResult {
		w.result = w.runner.Result()
		w.haveResult = true
	}

	return w.result
}
